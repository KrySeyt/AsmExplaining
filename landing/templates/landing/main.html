{% extends 'landing/base.html' %}

{% load static %}

{% block body %}
    <div class="position-absolute start-50 translate-middle-x">
        <h2>Арифметические команды на ассемблере <img src="{% static 'landing/img/roflan-pominki.png' %}" alt="" width="45" height="45"></h2>
    </div>

    <div class="container mt-5 w-75 p-3">
        <p>
            Кратко пробежимся о том, что вообще из себя представляет программа в памяти с модельной точки зрения. Весь
            код делится на три основные части, называемые сегментами: сегмент кода, хранящий в себе инструкции
            программы; сегмент данных, хранящий глобальные переменные, и сегмент стека, содержащий адреса возврата как
            для программы (для возврата в операционную систему), так и для вызовов подпрограмм (для возврата в главную
            программу).
        </p>
        <p>
            По умолчанию размер сегментов составляет 16 бит
        </p>
        <h3>Содержание:<alt="" width="30" height="30"></h3>
            <li>&nbsp&nbspИнструкция пересылки <a href="#mov">mov</a></li>
            <li>&nbsp&nbspИнструкция сложения <a href="#add">add</a></li>
            <li>&nbsp&nbspИнструкция вычитания <a href="#sub">sub</a></li>
            <li>&nbsp&nbspИнкремент и декремент <a href="#incdec">inc/dec</a></li>
            <li>&nbsp&nbspИнструкция умножения <a href="#mul">mul</a></li>
            <li>&nbsp&nbspИнструкция деления <a href="#div">div</a></li>
            </br>
        <p>
            <strong><a name="mov">Команда пересылки - MOV:</a></strong>
        </p>
        <p>
            Команду mov называют командой пересылки данных. Однако, это не совсем верное описание. Данная инструкция
            нужна для копирования данных из операнда-источника в операнд-получатель. Данные из операнда-источника при
            этом никуда не исчезают.
        </p>
        <p>Синтаксис:</p>
        <p>&nbsp&nbsp&nbsp&nbsp <i>mov приёмник, источник</i></p>
        <p>Приёмник – то, куда копируются данные. Источник – то, откуда они копируются. В качестве приёмника могут
            выступать: область памяти, сегментные регистры, регистры общего назначения или же переменные. В качестве источника
            могут выступать также область памяти, сегментные регистры, регистры общего назначения, переменные или же
            числа.
        </p>
        <p>Пример:</p>
        <p>&nbsp&nbsp&nbsp&nbsp <i>mov ax,dx ;запись в регистр ax значения из регистра dx</i></p>
        <p><strong><b>Важное замечание!</b></strong></p>
        <p><i>
            При работе с командой mov существуют некоторые ограничения. Адреса сегментов нужно загружать в сегменты
            регистра вручную, но помещать в них непосредственные значения, вроде имени сегмента или конкретного числа
            напрямую, запрещено. Копировать данные в эти регистры можно только из других регистров, например, регистров
            общего назначения. Поэтому для начала нужно загрузить адрес сегмента в свободный несегментный регистр, а
            после этого скопировать содержимое этого регистра в сегмент.
        </i></p>
        <p>Также хочется сказать, что нельзя пересылать данные из одной переменной непосредственно в другую переменную.
            Для такой пересылки необходимо задействовать промежуточный регистр.</p>
            </br>
        <p>
            <strong><a name="add">Команда сложения - ADD:</a></strong>
        </p>
        <p>Синтаксис:</p>
        <p>&nbsp&nbsp&nbsp&nbsp<i>add первый, второй операнд</i></p>
        <p>С помощью этой команды можно сложить два значения. Первый операнд складывается со вторым операндом, результат
            сложения помещается в первый операнд.</p>
        <p>В качестве первого операнда может выступать область памяти, регистр общего назначения. (С сегментным
            регистрами данная команда не работает)</p>
        <p>В качестве второго операнда может выступать область памяти, регистр общего назначения или же число.</p>
        <p>Пример использования:</p>
        <p>&nbsp&nbsp&nbsp&nbsp<i>add ax,27     ;ax = ax + 27</i>
            </br>
        &nbsp&nbsp&nbsp&nbsp<i>add bx,dx     ;bx = bx + dx</i></p>
        <p>Операнды должны иметь одинаковый размер. Т.е., например, данная строчка кода</p>
        <p><i>&nbsp&nbsp&nbsp&nbsp add ax,bl</i></p>
        <p>не выполнится, т.к. невозможно сложить значения в разноразмерных регистрах.</p>
        <p>Складывание чисел происходит в двоичной системе счисления
            </br>
        Графическое представление работы команды сложения:</p>
        <img src="{% static 'landing/img/add.png' %}" alt="">
        <p>Стоит отметить, что в зависимости от результата выполнения, команда add может изменять состояние флагов.</p>
        <p>Подробнее о флагах</p>
        </br>
        <p>
            <strong><a name="sub">Команда вычитания - SUB:</a></strong>
        </p>
        <p>Синтаксис:</p>
        <p>&nbsp&nbsp&nbsp&nbsp<i>sub первый операнд, второй операнд</i></p>
        <p>С помощью этой команды можно вычесть значение второго операнда из значения первого операнда. Подобно команде
            сложения, результат команды sub помещается на место первого операнда. Операнды в данном случае должны иметь
            одинаковый размер. </p>
        <p>Данная команда и в качестве первого операнда, и в качестве второго принимает точно такие же значения, как и
            команда сложения. Не может работать с сегментными регистрами!</p>
        <p>Пример использования:</p>
        <p>&nbsp&nbsp&nbsp&nbsp<i>sub ax,4     ;ax = ax - 4</i>
            </br>
        &nbsp&nbsp&nbsp&nbsp<i>sub al,cl    ;al = al + cl</i></p>
        <p>Вычитание одного значения из другого происходит в двоичной системе счисления.
            </br>
        Графическое представление работы команды вычитания:</p>
        <img src="{% static 'landing/img/sub.png' %}" alt="">
        <p>При выполнении вычитания необходимо обратить внимание на состояние регистра флагов процессора, так как
            существует шанс получить отрицательное число в качестве результата вычитания даже положительных чисел.
            Следовательно, надо отслеживать состояние флага SF (флаг знака) и, если он будет установлен, то принимать
            необходимые меры, если в этом возникнет необходимость. Например, использовать команду NEG, которая изменяет
            знак числа на противоположный.</p>
            </br>
        <p>
            <strong><a name="incdec">Инкремент и декремент.</a></strong>
        </p>
        <p>Прибавление единицы называется инкрементом, а вычитание — декрементом. Для этих операций существуют
            специальные команды процессора: INC и DEC. Они работают с одним операндом, который может находиться либо в
            регистре, либо в памяти. Эти команды не изменяют значение флага CF.</p>
        <p>Синтаксис:</p>
        <p>&nbsp&nbsp&nbsp&nbsp <i>inc операнд</i>
            </br>
        &nbsp&nbsp&nbsp&nbsp <i>dec операнд</i></p>
        <p>Логика работы команд:</p>
        <p>&nbsp&nbsp&nbsp&nbsp INC: < Операнд > = < Операнд > + 1</p>
        <img src="{% static 'landing/img/inc.png' %}" alt="">
        <p>&nbsp&nbsp&nbsp&nbsp DEC: < Операнд > = < Операнд > - 1</p>
        <img src="{% static 'landing/img/dec.png' %}" alt="">
        <p>Примеры использования:</p>
        <p>&nbsp&nbsp&nbsp&nbsp<i>inc bl ;bl = bl + 1</i>
            </br>
        &nbsp&nbsp&nbsp&nbsp<i>dec ax ;ax = ax – 1</i></p>
            </br>
        <p>
            <strong><a name="mul">Команда умножения - MUL:</a></strong>
        </p>
        <p>
            Есть две инструкции для умножения двоичных данных. Инструкция MUL (Multiply) обрабатывает беззнаковые
            данные, а IMUL (Integer Multiply) обрабатывает данные со знаком. Обе инструкции влияют на флаг переноса и
            переполнения.
            <br/>
            У команды mul только один операнд — <i>второй множитель</i>, который должен находиться в регистре или в памяти.
            Местоположение первого множителя и результата задаётся неявно и зависит от размера операнда:
        </p>
        <p>Синтаксис:</p>
            <p><i>&nbsp&nbsp&nbsp&nbsp mul операнд</i></p>
        <p>
            Отличие умножения от сложения и вычитания в том, что разрядность результата получается в 2 раза больше, чем
            разрядность сомножителей.     
            </br>
            Команда mul не работает непосредственно с числами, а только с регистрами общего назначения или с памятью.
        </p>

        <table class="position-absolute start-50 translate-middle-x">
            <tr>
                <th><strong>Размер операнда</strong></th>
                <th><strong>Множитель</strong></th>
                <th><strong>Результат</strong></th>
            </tr>
            <tr>
                <td>1 байт</td>
                <td>AL</td>
                <td>AX</td>
            </tr>
            <tr>
                <td>2 байта</td>
                <td>AX</td>
                <td>DX:AX</td>
            </tr>
            <tr>
                <td>4 байта</td>
                <td>EAX</td>
                <td>EDX:EAX</td>
            </tr>
        </table>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        <p></p>
        <p>Примеры использования:</p>
        <p>&nbsp&nbsp&nbsp&nbsp <i>mul bl ;AX = AL * BL</i>
            </br>
        &nbsp&nbsp&nbsp&nbsp <i>mul ax ;DX:AX = AX * AX</i></p>
        <p></p>
        </br>
        <p>
            <strong><a name="div">Команда деления - DIV:</a></strong>
        </p>
        <p>
            Операция деления генерирует два элемента — частное и остаток. В случае умножения переполнение не происходит,
            потому что регистры двойной длины используются для хранения результата. Однако в случае деления может
            произойти переполнение. Процессор генерирует прерывание, если происходит переполнение.
        </p>
        <p>
            Инструкция DIV (Divide) используется для данных без знака, а IDIV (Integer Divide) используется для данных со
            знаком.</p>
        <p>
            Cинтаксис команды DIV:
        </p>
        <p>&nbsp&nbsp&nbsp&nbsp <i>div операнд</i></p>
        <p>Операндом может быть область памяти и регистр общего назначения.</p>
        <p>
            Эта команда не работает с сегментными регистрами, а также не работает непосредственно с числами. То есть
            нельзя записать:
        </p>
        <p>&nbsp&nbsp&nbsp&nbsp <i>div 46</i></p>
        <p>Пример использования:</p>
        <p>&nbsp&nbsp&nbsp&nbsp <i>div bl ;al = ax / bl, остаток в ah</i>
            </br>
        &nbsp&nbsp&nbsp&nbsp <i>div cx ;ax = dx:ax / cx, остаток в dx</i></p>
        <p></p>
        <p>Логика работы команды:</p>

        <table class="position-absolute start-50 translate-middle-x">
            <tr>
                <th><strong>Размер операнда (делителя)</strong></th>
                <th><strong>Делимое</strong></th>
                <th><strong>Частное</strong></th>
                <th><strong>Остаток</strong></th>
            </tr>
            <tr>
                <td>1 байт</td>
                <td>AX</td>
                <td>AL</td>
                <td>AH</td>
            </tr>
            <tr>
                <td>2 байта</td>
                <td>DX:AX</td>
                <td>AX</td>
                <td>DX</td>
            </tr>
            <tr>
                <td>4 байта</td>
                <td>EDX:EAX</td>
                <td>EAX</td>
                <td>EDX</td>
            </tr>
        </table>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        <p>Инструкция div выполняет остаток от деления:</p>
        <p>&nbspЕсли операнд является байтом, то в младший байт (AL) записывается AX / операнд
            </br>
        &nbspЕсли операнд является словом, то в регистр (AX) записывается (DX AX) / операнд</p>
        <p>Остаток от деления, если таковой имеется, будет записан:</p>
        <p>&nbspВ регистр АН, если операнд – это байт
            </br>
        &nbspВ регистр DX, если операнд – это слово</p>
        </br>
        <p>Никакие флаги при этом не изменяются.</p>
    </div>
{% endblock body %}
